package net.sf.jclec.problem.classification.algorithm.tan;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.base.Rule;
import net.sf.jclec.problem.classification.crisprule.CrispRuleBase;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.instance.IInstance;

/**
 * Classifier for Tan et al. 2002 - Mining multiple comprehensible classification rules using genetic programming<p/>
 *
 * The Tan et al. algorithm states that the rules within the classifier must be sorted according to their specificity value.
 * This procedure is carried out in the sortClassifier() method.
 *
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna
 * @author Alberto Cano
 * @author Juan Luis Olmo
 */

public class TanClassifier extends CrispRuleBase
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -6792167360656990171L;

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------------- Constructor
	/////////////////////////////////////////////////////////////////

	/**
	 * Default (empty) constructor
	 */

	public TanClassifier()
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Sort the rules based on the sensitivity
	 *
	 * @param dataset the dataset
	 */

	public void sortClassifier(IDataset dataset, String fitness)
	{
		int[] tp, fp, tn, fn;

		int numRules = getClassificationRules().size();
		tp = new int[numRules];
		tn = new int[numRules];
		fn = new int[numRules];
		fp = new int[numRules];

		double [] OMAE = new double[numRules];
		int num_instancias = dataset.numberOfInstances();
		int numClasses = dataset.getMetadata().numberOfClasses();

		// Calculates the confusion matrix for each rule
		for(IInstance instance : dataset.getInstances())
		{
			double value = instance.getValue(dataset.getMetadata().getClassIndex());

			for (int i = 0; i < numRules; i++)
			{
				if ((Boolean) getClassificationRules().get(i).covers(instance))
				{
					OMAE[i] += Math.abs(getClassificationRules().get(i).getConsequent() - value);
					if (getClassificationRules().get(i).getConsequent() == value)
						tp[i]++;
					else
						fp[i]++;
				}
				else
				{
					if (getClassificationRules().get(i).getConsequent() != value)
						tn[i]++;
					else {
						fn[i]++;
						OMAE[i] += numClasses;
					}
				}
			}
		}

		for (int i = 0; i < numRules; i++) {
			OMAE[i] /= (double) num_instancias;
		}

		// Calculates the sensitivity for each rule
		double[] se = new double[numRules];

		for (int i = 0; i < numRules; i++)
		{
			if (tn[i] + fp[i] == 0)
				se[i] = 0;
			else
				se[i] = tn[i] / (double)(tn[i] + fp[i]);
		}

		List<Rule> rulesAux = new ArrayList<Rule>();

		for(int j = 0; j < numRules; j++)
		{
			double maxSe = 0;
			int maxSeRule = 0;
			double minOMAE = Double.POSITIVE_INFINITY;
			int minOMAERule = 0;

			for(int i = 0; i < numRules; i++)
			{
				if(!rulesAux.contains(getClassificationRule(i)))
				{
					if (OMAE[i] < minOMAE) {
						minOMAE = OMAE[i];
						minOMAERule = i;
					}

					if(se[i] >= maxSe)
					{
						maxSe = se[i];
						maxSeRule = i;
					}
				}
			}

			if (fitness.equals("OMAE")) {
				rulesAux.add(getClassificationRule(minOMAERule));
			} else {
				rulesAux.add(getClassificationRule(maxSeRule));
			}
		}

		getClassificationRules().clear();
		setClassificationRules(rulesAux);
	}
}
